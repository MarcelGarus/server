import make.mar

struct Blog { articles: Slice[Article] }
struct Article {
  id: String,
  state: ArticleState,
  title: MarkdownInline,
  subtitle: MarkdownInline,
  content: Markdown,
}
enum ArticleState { draft, timeless, published: Date }
struct Date { year: Int, month: Int, day: Int }

fun get(blog: Blog, id: String): Article {
  for article in blog.articles do if article.id == id then return article
  panic("No article with ID {id}")
}

| Panics for published articles, prints a warning for draft ones.
fun found_inconsistency(state: ArticleState, inconsistency: String) {
  if state is draft
  then println("  WARNING: {inconsistency}")
  else panic(inconsistency)
}

fun parse_article(filename: String, content: String): Article {
  var filename = filename.&
  filename.trim_suffix(".md")
  var state_and_id = filename.split(" ")
  state_and_id.len == 2 or panic("blog article files should have two
    'components in the filename, but {filename} has {state_and_id.len}")

  var state = state_and_id.get(0).parse_state()
  var id = state_and_id.get(1)

  if content.chars().iter().&.contains(carriage_return) then
    found_inconsistency(state, "Blog article contains carriage return.")

  var content = content.parse_markdown() or(err) {
    found_inconsistency(state, "When parsing markdown:\n{err}")
    Markdown.multiple(list(
      Markdown.heading(MarkdownHeading {
        content = MarkdownInline.text("TODO: Fix markdown").put_on_heap(), level = 1,
      }),
      Markdown.heading(MarkdownHeading {
        content = MarkdownInline.text("It doesn't parse").put_on_heap(), level = 2,
      }),
      Markdown.code(MarkdownCode { language = "text", code = err.format()})
    ).to_slice())
  }

  var extracted_titles = extract_title_and_subtitle(state, content)
  var title = extracted_titles.a
  var subtitle = extracted_titles.b
  content = extracted_titles.c

  Article { id, state, title, subtitle, content }
}
fun parse_state(state: String): ArticleState {
  if state == "draft" then return ArticleState.draft
  if state == "timeless" then return ArticleState.timeless
  var parts = state.split("-")
  parts.len == 3 or panic("date should contain 3 components, but \"{state}\"
    'contains {parts.len} parts")

  ArticleState.published(Date {
    year  = parts.get(0).parse_int() or panic("Invalid year {parts.get(0)}"),
    month = parts.get(1).parse_int() or panic("Invalid month {parts.get(1)}"),
    day   = parts.get(2).parse_int() or panic("Invalid day {parts.get(2)}"),
  })
}

fun extract_title_and_subtitle(
  state: ArticleState, markdown: Markdown
): Tuple3[MarkdownInline, MarkdownInline, Markdown] {
  var blocks = markdown.multiple or {
    found_inconsistency(
      state,
      "Can't extract title and subtitle because article doesn't consist of
      'multiple blocks."
    )
    return tuple(
      MarkdownInline.text("TODO: Markdown doesn't consist of multiple blocks"),
      MarkdownInline.text("TODO: Add subtitle"),
      markdown,
    )
  }
  blocks.len >= 2 or {
    found_inconsistency(
      state, "Not enough content to extract title and subtitle."
    )
    return tuple(
      MarkdownInline.text("TODO: Add title"),
      MarkdownInline.text("TODO: Add subtitle"),
      markdown
    )
  }

  var heading = blocks.get(0).heading or {
    found_inconsistency(state, "No title.")
    return tuple(
      MarkdownInline.text("TODO: Add title"),
      MarkdownInline.text("TODO: Add subtitle"),
      markdown
    )
  }
  if heading.level != 1 then
    found_inconsistency(state, "First heading has level {heading.level}")
  var title = heading.content.*

  var heading = blocks.get(1).heading or {
    found_inconsistency(state, "No subtitle.")
    return tuple(title, MarkdownInline.text("TODO: Add subtitle"), markdown)
  }
  if heading.level != 2 then
    found_inconsistency(state, "Subtitle has heading level {heading.level}")
  var subtitle = heading.content.*

  tuple(title, subtitle, Markdown.multiple(blocks.without_first(2)))
}
